<!Doctype html>
<html>
    <head>
        <title>Testes com Three.js - Experimento inicial com um wireframe</title>
        <meta charset="utf-8">
        <script type="text/javascript" src="js/three.min.js"></script>
        <script type="text/javascript" src="js/three.js"></script>
        <script type="text/javascript" src="js/OrbitControls.js"></script>
        <script type="text/javascript" src="js/countries.geo.json"></script>
        <script type="text/javascript" src="js/lands.geo.json"></script>
        <style>
            *{
                margin: 0;
                padding: 0;
            }
            html, body{
                overflow: hidden;
            }
        </style>  

        <script type="text/javascript">
            function add_shape(shape_points) {
                var shape = new THREE.Shape(shape_points);
                var shape_geom;
                var inner_radius = 30;
                var outer_radius = 35;

                shape_geom = shape.extrude({
                    amount: outer_radius - inner_radius,
                    bevelEnabled: false
                });

                var offset = 0;
                offset = Math.random() * .5;

                shape_geom.vertices.forEach(function (vert, index) {
                    var radius = 0.0;
                    if (index < shape_geom.vertices.length / 2) {
                        radius = inner_radius;
                    } else {
                        radius = inner_radius + .5 + offset;
                    }
                    var phi = (90.0 - vert.y) * Math.PI / 180.0;
                    var theta = (360.0 - vert.x) * Math.PI / 180.0;
                    vert.x = radius * Math.sin(phi) * Math.cos(theta);;
                    vert.y = radius * Math.cos(phi);;
                    vert.z = radius * Math.sin(phi) * Math.sin(theta);;
                });

                var color = new THREE.Color(0xaa9933);
                color.setHSL(Math.random(),0.8,0.8 );

                var shape_material = new THREE.MeshPhongMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });
                var shape_mesh = new THREE.Mesh(shape_geom, shape_material);
                root_object.add(shape_mesh);
            }

            function add_all_countries() {

                root_object = 0;

                if ( root_object ) {
                    scene.remove(root_object);
                }

                root_object = new THREE.Object3D();
                scene.add(root_object);

                countries.features.forEach(function (country) {
                    if (country.geometry.coordinates.length === 1) {
                        var shape_points = [];
                        country.geometry.coordinates[0].forEach(function (points) {
                            shape_points.push(new THREE.Vector2(points[0], points[1]));
                        });
                        add_shape(shape_points);
                    } else {
                        country.geometry.coordinates.forEach(function (coord_set) {
                            if (coord_set.length == 1) {
                                var shape_points = [];
                                coord_set[0].forEach(function (points) {
                                    shape_points.push(new THREE.Vector2(points[0], points[1]));
                                });
                                add_shape(shape_points);
                            } else {
                                var shape_points = [];
                                coord_set.forEach(function (points) {
                                    shape_points.push(new THREE.Vector2(points[0], points[1]));
                                });
                                add_shape(shape_points);
                            }
                        });
                    }
                });
            }

            function add_all_lands(){
                root_object = 0;

                if ( root_object ) {
                    scene.remove(root_object);
                }

                root_object = new THREE.Object3D();
                scene.add(root_object);

                lands.features.forEach(function (land) {
                    land.geometry.coordinates.forEach(function (coord_set) {
                        if (coord_set.length == 1) {
                            var shape_points = [];
                            coord_set[0].forEach(function (points) {
                                shape_points.push(new THREE.Vector2(points[0], points[1]));
                            });
                            add_shape(shape_points);
                        } else {
                            var shape_points = [];
                            coord_set.forEach(function (points) {
                                shape_points.push(new THREE.Vector2(points[0], points[1]));
                            });
                            add_shape(shape_points);
                        }
                    });
                });
            }

            function createLights() {
                light = new THREE.HemisphereLight(0xffffff, 0xffffff, .5)

                shadowLight = new THREE.DirectionalLight(0xffffff, .8);
                shadowLight.position.set(200, 200, 200);
                shadowLight.castShadow = true;
                shadowLight.shadowDarkness = .2;

                backLight = new THREE.DirectionalLight(0xffffff, .4);
                backLight.position.set(-100, 200, 50);
                backLight.shadowDarkness = .1;
                backLight.castShadow = true;

                scene.add(backLight);
                scene.add(light);
                scene.add(shadowLight);
            }

            function createPlanet(){
                moonMat =  new THREE.MeshLambertMaterial ({
                    color: 0x4169E1,
                    wireframe: false,
                    shading:THREE.FlatShading,
                    vertexColors: THREE.FaceColors
                });

                var moonGeometry = new THREE.SphereGeometry(30, 8, 8 );
                moon = new THREE.Mesh(moonGeometry, moonMat);

                scene.add( moon );
            }
        </script>

    </head>
    <body>

        <script type="text/javascript">
            //criando a cena
            var scene = new THREE.Scene(), WIDTH = window.innerWidth, HEIGHT = window.innerHeight;
            
            //criando câmera em perspectiva
            // - Campo de visão (FOV)
            // - Relação do aspecto (aspect ratio com o tamanho da janela)
            // - Plano de recorte próximo (limite de renderização próximo)
            // - Plano de recorte afastado (limite de renderização distante)
            var camera = new THREE.PerspectiveCamera(45, WIDTH / HEIGHT, 0.1, 1000);
            
            //criando objeto de renderização WebGL
            var renderer = new THREE.WebGLRenderer();
            renderer.setSize( WIDTH, HEIGHT ); //configurando dimensões do renderizador
            
            //atribuindo ao DOM e ao body do html
            document.getElementsByTagName('body')[0].appendChild( renderer.domElement  );

            createLights();

            //Habilitando movimento de orbita
            var orbit = new THREE.OrbitControls( camera, renderer.domElement );
            orbit.enableZoom = true;

            createPlanet();
            
            add_all_countries();

            //definindo a posição da câmera
            camera.position.z = 100;

            //definindo a cena e a câmera utilizada
            renderer.render(scene, camera);

            //função para controlar a renderização da cena
            function render(){
                //definindo a cena e a câmera utilizada
                renderer.render(scene, camera);
                 
                //alterando valores dos eixos para executar algum movimento
                //sphere.rotation.z += 0.001;
                //sphere.rotation.y += 0.001;
                //sphere.rotation.x += 0.001;
                 
                //executando recursivamente
                requestAnimationFrame(render);
            }
             
            //executando a função de renderização
            render();
        </script>
    </body>
</html>